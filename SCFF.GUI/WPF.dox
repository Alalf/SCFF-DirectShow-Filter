/*!
@page wpf C# / WPFプログラミングメモ (by 2013/01/02 Alalf)
@brief WPFはMVVM/DataBinding/BeginInvoke/...がなくても普通に使えそう！

## C#/WPFプログラムの基本的な作り方
C# は C++ に比べるととてもDLL（アセンブリ）が作りやすくデバッグしやすく統合しやすいので、
まずプログラムを二つ（かそれ以上）のプロジェクトに分割するのがおすすめのようです：
- GUIに関係しないDLL(アセンブリ)を生成するためのプロジェクトA
- GUIに関係したExeを生成するためのプロジェクトB

都合よくVisual Studio 2012のDLLプロジェクトテンプレートは
GUIに関係したアセンブリに依存しないようになっているので、
自分で依存関係を追加したりしない限りはプログラムを綺麗に二分割できるはずです。

本来アセンブリ分割は再利用性をあげるために行われるものですが、
C# では半ばソースファイルの整理を目的にどんどん分割しちゃってよさそうです。
もし必要だと思うのならばTestプロジェクトを作ってもいいかもしれません。
（個人的にはテストを書いてくれる利害関係者がいないなら、
「自分で書いて自分でレビュー」の繰りかえしのほうがいいと思いますが……）

C# ではGUIを作るためのツールボックスとしてWPFとWinForms（とWinRT）があります。

WinFormsにはメモリ使用量が小さく(WPFの1/5)既存の資産（コード・ドキュメント）が多い
という利点があり、対してWPFにはXAMLの将来性と美しいUIをGPU支援付きで構築できるいう利点があります。
SCFF.GUIではこのXAMLの将来性（と後から知った柔軟性）を理由にWPFを採用しました。

WPFのプログラムを書く上で気をつけていることを４つあげます。以下ひとつひとつ解説します:
- わからない事に関しては素直に使うのをあきらめること
- Applicationクラスにstaticシングルトンのデータをおくこと
- ユーザーインタフェースを可能な限りUserControl(XAML要素)で分割すること
- UserControlの独立性を守るために、RoutedCommandを利用すること


## わからない事に関しては素直に使うのをあきらめること
WPF/.NETはとても多機能で、JavaのDAO、ffmpegのSWScale、C++のSTL/Boostの一部の機能が標準で組み込まれています。
正直なところこれらをすべて理解し、すべて正しい方法で使うということはできないと判断しました。
よって、「わからない事に関しては素直に使うのをあきらめること」をキーワードに次のような取捨選択ガイドラインを作りました。


### DataBindingに関連したすべての機能を利用しない

この時点でエキスパートのみなさまはずっこけるかと思います。ですが、私の理解の範囲内ではDataBindingというのは
「きわめて注意深く正規化されたリレーショナルデータベースの1レコードをGUIで操作する」
という場合において真の力を発揮するのではないかと思い、作りたいプログラムのサイズを考えてDataBindingの利用はやめました。

もう少し具体的な話をすると、小規模なプログラムではほぼすべてのデータが双方向バインディングになると思うのですが、
このためにすべてのViewModelにINotifyPropertyChangedを実装する事になり、
リフレクションの利用を強制されます（しかもこれが結構重い・・・）。

このDataBindingにもいえることですが、
「ある機能を使うために、自分の小さなクラスによくわからない巨大な親クラス、親インタフェースを付けること」
を強制された時点で自分はその機能の利用はあきらめるようにしています。


### MVVMにこだわらない
DataBindingを利用しない時点でViewModelの必要性がなくなりました。

このMVVMは正直なところあまりに難しい、というか一言で「MとVM、VとVMの境界はどうやって決まるのか」を説明するのが難しく、
自分で説明できないものを使うのはいやなので後述のRoutedCommandと合わせてあまりこだわらないようにしました。


### [Attribute]が必要となる機能は利用しない
C# / .NET / WPFだけでも理解が追いつかないのに、
更にその上のメタ言語を利用するのは「わからないこと」を増やすだけだと判断し利用をあきらめました。

具体的に言うとDataContractによるオブジェクトのシリアライズ、デシリアライズをあきらめる事にしました。
これは以下の「何にでも対応した機能は使わない」にも関連しています。


### 何にでも対応した機能は使わない
.NETは巨大なフレームワークですが、すべてのWindowsプログラミングで必要となる機能が網羅されているかというとそうではないようです。

たとえば.NETフレームワークにはレジストリ入出力機能があるのにINIファイルへの入出力機能がありません。
代わりにDataContractやXMLSerializerを使えということなのでしょうが、
小さなプログラムの設定ファイルにXML形式が本当に必要かといわれると疑問に思います。
しかもこれらのシリアライザ、デシリアライザにはクライアント側のクラスに厳密な条件を強制されます。

このような何にでも対応した機能は完全な理解が難しく、理解したところで最善の選択肢でもない事が多いので使わない事にしました。


## Applicationクラスにstaticシングルトンのデータをおくこと
昔からよく使われる手ですが、本来アプリケーションが管理するデータというのはGUIには依存しません。
よって、こういったデータはApplicationクラスに管理させるほうが自然です。
自分は三つの情報をそれぞれひとつずつシングルトンとしてApplicationクラスに持たせています。

- App.Options (ApplicationSettingsの代替)
- App.Document (MainWindowで開いているドキュメントデータ。SCFF.GUIではApp.Profile)
- App.RuntimeOptions (実行時にのみ存在するオプション。例：今開いているドキュメントのパス)

GUIプログラムではこれらのデータをいかに参照・編集するかが問題になってきます。


## ユーザーインタフェースを可能な限りUserControl(XAML要素)で分割すること
WPFのUI記述言語であるXAMLはXMLの要素がひとつのコントロール(FrameworkElement)に対応しています。
つまりユーザコントロールの配置＝単なるXML要素の置換となっていて、UIエディタで内容まで見えるなど
「いくらUIをユーザコントロールで分割してもデメリットがない」ようです。
このメリットを生かさない手はありません！


### どの単位でユーザコントロールを分割するのか
自分のガイドラインとしては：
- GroupBox内のコントロールはひとつのUserControlにするべき
- Expander内のコントロールはひとつのUserControlにするべき
- ToolBarはひとつのUserControlにするべき
- MenuBarはひとつのUserControlにするべき
- ドキュメントビューアー的なコントロールはUserControlにするべき


### ユーザコントロールに共通するインタフェースについて



## UserControlの独立性を守るために、RoutedCommandを利用すること


### RoutedCommandの使用方法ガイドライン

- 前提1: MainWindowのみがすべてのUserControlを知っている
- 前提2: すべてのUserControlはApp.Profile/App.Optionsを知っている
- 前提3: すべてのUserControlはお互いを知らない
- 前提4: すべてのUserControlはMainWindowを知らない

これらの前提に基づいて、必要最低限のコマンドを用意する。


### コマンドがどれだけ必要か？
まずRoutedCommandsを二つに分割する

- 他のコントロールへの通信用
- 機能の実行依頼用


### RoutedCommandの制限
Loadedイベント中にExecuteしてもコマンドを捕まえる事ができないようだ。


## 補足

### コメントの付け方
C#には一応XMLドキュメント(例: ///<summary>がいよう</summary>)がありますが、
/docオプションの出力を利用したプログラム(Sandcastle)は更新が停止されたようです。
現状での利点はIntellisenceのコードコンプリート時に情報が追加されるのみ？

関数名と引数名をちゃんとつけられるのならXMLドキュメントの必要はほぼないと思います。
XML要素を毎回入力するのも大変なので、SCFF GUIではdoxygen/javadocを採用しました。

### WPFとマルチスレッド
WPFはUIスレッドひとつでどうにか何とかするというコンセプトの元で設計が行われているようで、
他スレッドからUIに関連するオブジェクトをさわることもできないようになっています。
（具体的にはDispatcherObjectを継承したすべてのクラスのオブジェクト）

このため、たとえば他のスレッドでBitmapSource(DispatcherObjectを継承している)を生成し、
UIスレッドでそのオブジェクトをDrawingContext.DrawImage(bitmap, rect)する、
といった場合、BitmapSource.Freeze()を呼び出して変更不可能にしてから渡す必要があります。

- 重い処理には独立したスレッドであるSystem.Threading.Timerを使う
- 軽い処理にはUIスレッドで動作するDispatcherTimerを使う
- スレッド間でやり取りされるデータはPOD(Plain Old Data)か、Freezableなオブジェクトに制限


### パフォーマンスに関連した注意点

- まずはO(N)を疑うこと
- 次にリフレクションを疑うこと
- UIスレッドで重い処理をさせていないかを疑うこと


 */